# 6 模块

如果你退出 python 的解释器然后重新进入的话，你之前定义的函数和变量都会丢失。因此，如果你想写一个有点长的程序，你最好事先准备一个文本编辑器，然后在解释器直接运行这个文件。这是就是所谓的创建 *脚本*。随着你的程序变得更长，你也许要把它分割成若干的文件，这样维护起来更方便。你也可以用一个你已经在若干程序中写好的随时可用的函数，而不用把这个函数的定义复制到每一个程序中。

Python 有一种把函数定义在一个文件的方法，你可以在脚本中，或者在解释器的交互实例中使用这个文件。这样的一个文件就叫做 *模块*。在一个模块中的定义可以 *导出* 到其他的模块中，或者 *main* 模块中 (一个变量的集合，你可以在脚本中得到这些变量，这些脚本在计算器模式下高层次被执行)。

一个模块文件包含了 Python 的定义和声明。文件名就是模块名加上 `.py` 后缀。在一个模块中，模块的名字 (作为字符串) 可以作为全局变量 `__name__`而得到。 在当前目录下， 用下面的内容创建一个名为 `fibo.py` 的文件：

```python
# Fibonacci numbers module

def fib(n):    # write Fibonacci series up to n
    a, b = 0, 1
    while b < n:
        print(b, end=' ')
        a, b = b, a+b
    print()

def fib2(n):   # return Fibonacci series up to n
    result = []
    a, b = 0, 1
    while b < n:
        result.append(b)
        a, b = b, a+b
    return result
```

现在进入 Python 解释器然后使用下面的命令导入这个模块：

```python
>>> import fibo
```

在当前的符号表中，不用直接输入在 `fibo` 中定义的函数名字。它仅仅在里面输入了模块名 `fibo`。使用模块名你就可以使用这些函数了：

```python
>>> fibo.fib(1000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
>>> fibo.fib2(100)
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
>>> fibo.__name__
'fibo'
```

如果你经常使用一个函数，你可以把这个函数赋值给一个本地的变量名：

```python
>>> fib = fibo.fib
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
```

## 6.1 模块的更多介绍

一个模块可以像函数定义那样包含可执行的语句。这些语句用来初始化模块。他们只有在 *第一次* 在导入 (import) 语句遇到模块名的时候才会执行。(如果文件是作为一个脚本执行的，他们也会运行。)

*注释* 实际上，函数的定义也是 被“执行” 的语句。模块层面的函数定义的执行在模块的全局符号表中进入函数名。

每一个模块都有属于自己的私有符号表，一般用来作为模块中定义的所有函数的全局符号表。因此，一个模块的作者可以使用全局变量儿不用担心与用户的全局变量意外的冲突。另一方面，如果你知道你正在做什么，你可以使用相同的用于指代函数的符号来得到模块的全局变量，`modename.itemname`。

模块可以导入其他模块。这很常见，但是并不要求把所有的 `import` 语句放在一个模块的最开头 (或者脚本，就此而言)。被导入的模块名字放在导入其他模块的模块的全局符号表中。

有一个 `import` 语句的一种变体，它从一个模块中直接把模块名导入到模块的符号表中。举个例子：

```python
>>> from fibo import fib, fib2
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
```

这并没有引入从本地符号表中导入的模块名 (所以在这个例子中，`fibo` 是未定义的)。

甚至还有一种变体，用它导入所有模块中定义的名字：

```python
>>> from fibo import *
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
```

这就导入了所有除了以下划线 (`_`) 开头的名字。在大多数情况下，Python 程序员不用这种用法，因为它往解释器中引入了一系列未知的名字，有可能会隐藏一些你已经定义过的东西。

注意，在一般的实际应用中，从一个模块或者包中导入 `*` 是不赞成使用的，因为这常常会导致可读性很差的代码。然而，在交互会话可以这么使用来减少输入。

**注意**：因为效率性的原因，每一个模块在每一个解释器会话中只导入一次。因此，如果你想改变你的模块，你就必须要重启解释器，否则，如果它仅仅是一个你想用来交互性的测试的一个模块，就使用 `importlib.reload()`。举个例子：`import importlib; importlib.reload(modulename)`。