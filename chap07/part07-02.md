## 7.2 读写文件

`open` 函数返回一个 **文件对象**，通常情况下有两个参数: `open(filename, mode)`

```python
>>> f = open('workfile', w)
```

第一个参数是一个包含文件名的字符串。第二个参数是另一个包含一些字符串，这些字符串描述了在文件中将被使用的方法。当文件仅仅被读取的时候， *mode* 可以是 `'r'`, `'w'` 用作只写（已存在的同名文件会被擦除），`'a'` 会打开附加文件，任何写入文件的数据都会被加到文件末尾。`'r+'` 打开同时供读和写的文件。*mode* 参数是可选的。如果没有指定，就默认是 `'r'` .

通常情况下，文件在 *文本模式* 下打开，也就是说，你从文件中读写字符串，这些字符串以特定的编码格式编码。如果编码格式没有指定，那么默认值就是平台依赖 (参考 open()). 在模式末尾加上 `'b'` 用来以 *二进制模式* 打开文件：现在数据已字节对象的形式读出和写入。这种模式应该用于所有不包含文本的文件。

在文本模式下，读出时默认转换具体平台的行结束符 (Unix 下是 `\n`, Windows 下是 `\r\n`). 写入时默认把 `\n` 转换回不同平台的特有行尾结束符。幕后对文件数据的修改对文本文件来说是ok的，但是会损坏二进制文件，如 `JPEG` 或者 `EXE` 文件。

处理文件对象的时候，使用 `with` 关键字是一个很好的实践。好处是文件在使用结束的时候可以正确的关闭，即使在某一处抛出了异常都没事。使用 `with` 也比使用 **try-finally** 更简洁。

```python
>>> with open('workfile') as f:
...     read_data = f.read()
>>> f.closed
True
```

如果你使用了 `with` 关键字，你需要调用 `f.close` 来关闭文件，以立即释放它所占用的系统资源。如果你不显式的关闭一个文件，Python 的垃圾回收器最后会销毁这个文件对象，然后帮你关闭打开的文件，但是这个文件会保持一段时间的打开状态。另一个风险就是不同的 Python 解释器会在不同时间执行垃圾回收。

在一个文件关闭之后，使用 `with` 语句或者调用 `f.close` 尝试使用这个文件对象都会自动失效。

```python
>>> f.close()
>>> f.read()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: I/O operation on closed file
```

